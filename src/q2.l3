(define append 
  (lambda(lst1 lst2)
      (if (eq? lst1 '())
        lst2
        (cons (car lst1)(append (cdr lst1) lst2))                 
       )
  )
)

(define reverse 
  (lambda (lst)
      (if (eq? lst '())
        '()
        (append (reverse (cdr lst)) (list (car lst)))                 
       )
  )
)

(define duplicate-item
   (lambda(item dup-count)
      (if (= dup-count 0)
      '()
      (append (cons item '()) (duplicate-item item (- dup-count 1)))
      )
   )
)

(define duplicate-items
   (lambda(lst dup-count)
      (if (eq? lst '())
      lst
      (append (duplicate-item (car lst) (car dup-count)) (duplicate-items (cdr lst) (append (cdr dup-count) (cons (car dup-count) '()))))
      )
   )
)

(define empty?
  (lambda (lst)
    (eq? lst '()))
 )

(define remove-duplicates
  (lambda (num-to-remove lst)
    (if (empty? lst) '()
      (if (= (car lst) num-to-remove) (remove-duplicates num-to-remove (cdr lst))
      (append (list(car lst)) (remove-duplicates num-to-remove (cdr lst)))))
  )
)

(define payment
  (lambda (n coins-lst)
    (if (= n 0) 1
      (if (< n 0) 0
        (if (empty? coins-lst) 0
        (+ (payment n (remove-duplicates (car coins-lst) (cdr coins-lst)))
          (payment (- n (car coins-lst)) (cdr coins-lst))))))
  )
)
                               
(define compose-n
  (lambda( f n)
    (if (= n 0) 1
    (if (= n 1) f
    (lambda (x) (f ((compose-n f (- n 1)) x)))))
  )
)